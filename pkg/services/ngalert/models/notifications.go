package models

import (
	"encoding/binary"
	"hash/fnv"
	"slices"
	"sort"
	"unsafe"

	"github.com/grafana/alerting/models"
	"github.com/prometheus/alertmanager/pkg/labels"
	"github.com/prometheus/common/model"

	"github.com/grafana/grafana-plugin-sdk-go/data"

	"github.com/grafana/grafana/pkg/services/ngalert/api/tooling/definitions"
)

const (
	ReceiverNameLabel      = "__grafana_receiver__"
	RouteSettingsHashLabel = "__grafana_route_settings_hash__"
	AutogeneratedLabel     = "__grafana_autogenerated__"
)

type NotificationSettings struct {
	Receiver string

	GroupBy           []string
	GroupWait         *model.Duration
	GroupInterval     *model.Duration
	RepeatInterval    *model.Duration
	MuteTimeIntervals []string

	// Cached hash of the settings.
	hash data.Fingerprint
}

func (s *NotificationSettings) ToLabels() data.Labels {
	result := make(data.Labels, 3)
	result[AutogeneratedLabel] = "true"
	result[ReceiverNameLabel] = s.Receiver // TODO base64?
	if !s.isAllDefault() {
		result[RouteSettingsHashLabel] = s.Fingerprint().String()
	}
	return result
}

func (s *NotificationSettings) Equals(other *NotificationSettings) bool {
	if s == nil && other == nil {
		return true
	}
	if s == nil || other == nil {
		return false
	}
	if s.Receiver != other.Receiver {
		return false
	}
	if s.isAllDefault() == other.isAllDefault() {
		return true
	}
	return s.Fingerprint() == other.Fingerprint() // TODO improve it later
}

func (s *NotificationSettings) isAllDefault() bool {
	return len(s.GroupBy) == 0 && s.GroupWait == nil && s.GroupInterval == nil && s.RepeatInterval == nil && len(s.MuteTimeIntervals) == 0
}

// normalize ensures that settings are in a consistent canonical form. This is necessary so that congruent settings
// have the same fingerprint.
func (s *NotificationSettings) normalize() {
	// Folder and alert rule name are always included in the groupings.
	var groupByString []string
	for _, gb := range s.GroupBy {
		if gb == models.FolderTitleLabel || gb == model.AlertNameLabel {
			continue
		}
		groupByString = append(groupByString, gb)
	}

	if len(groupByString) > 0 {
		s.GroupBy = append([]string{models.FolderTitleLabel, model.AlertNameLabel}, groupByString...)
	} else {
		s.GroupBy = groupByString
	}
}

func (s *NotificationSettings) Fingerprint() data.Fingerprint {
	if s.hash != 0 {
		return s.hash
	}
	// Ensure that the settings are normalized before fingerprinting.
	s.normalize()

	h := fnv.New64()
	tmp := make([]byte, 8)

	writeString := func(s string) {
		// save on extra slice allocation when string is converted to bytes.
		_, _ = h.Write(unsafe.Slice(unsafe.StringData(s), len(s))) //nolint:gosec
		// ignore errors returned by Write method because fnv never returns them.
		_, _ = h.Write([]byte{255}) // use an invalid utf-8 sequence as separator
	}
	writeDuration := func(d *model.Duration) {
		if d == nil {
			_, _ = h.Write([]byte{255})
		} else {
			binary.LittleEndian.PutUint64(tmp, uint64(*d))
			_, _ = h.Write(tmp)
			_, _ = h.Write([]byte{255})
		}
	}

	writeString(s.Receiver)
	for _, gb := range s.GroupBy {
		writeString(gb)
	}
	writeDuration(s.GroupWait)
	writeDuration(s.GroupInterval)
	writeDuration(s.RepeatInterval)
	for _, interval := range s.MuteTimeIntervals {
		writeString(interval)
	}
	s.hash = data.Fingerprint(h.Sum64())
	return s.hash
}

type AutogeneratedRoute struct {
	Route        *definitions.Route
	baseSettings []NotificationSettings
	hash         data.Fingerprint
}

func NewAutogeneratedRoute(settings []NotificationSettings) (*AutogeneratedRoute, error) {
	// Keep only unique settings.
	seen := make(map[data.Fingerprint]struct{})
	uniq := make([]NotificationSettings, 0, len(seen))
	for _, s := range settings {
		if _, ok := seen[s.Fingerprint()]; ok {
			continue
		}
		uniq = append(uniq, s)
		seen[s.Fingerprint()] = struct{}{}
	}

	r, err := generateRoute(uniq)
	if err != nil {
		return nil, err
	}

	return &AutogeneratedRoute{
		baseSettings: uniq,
		Route:        r,
	}, nil
}

// generateRoute creates an autogenerated route from the provided settings.
func generateRoute(settings []NotificationSettings) (*definitions.Route, error) {
	rootMatcher, err := labels.NewMatcher(labels.MatchEqual, AutogeneratedLabel, "true")
	if err != nil {
		return nil, err
	}

	autoGenRoot := &definitions.Route{
		Receiver:       "", // Will be populated when combined with user-created route.
		ObjectMatchers: definitions.ObjectMatchers{rootMatcher},
		Continue:       false, // We explicitly don't continue toward user-created routes if this matches.
	}

	// Generate a route for each unique receiver.
	sort.Slice(settings, func(i, j int) bool { return settings[i].Fingerprint() < settings[j].Fingerprint() })

	receiverRoutes := make(map[string]*definitions.Route)
	for _, s := range settings {
		receiverRoute, ok := receiverRoutes[s.Receiver]
		if !ok {
			contactMatcher, err := labels.NewMatcher(labels.MatchEqual, ReceiverNameLabel, s.Receiver)
			if err != nil {
				return nil, err
			}
			receiverRoute = &definitions.Route{
				Receiver:       s.Receiver,
				ObjectMatchers: definitions.ObjectMatchers{contactMatcher},
				// We continue on to check all other contact routes.
				Continue: true,
				// Since we'll have many rules from different folders using this policy, we ensure it has these necessary groupings.
				GroupByStr: []string{models.FolderTitleLabel, model.AlertNameLabel},
			}
			receiverRoutes[s.Receiver] = receiverRoute
			autoGenRoot.Routes = append(autoGenRoot.Routes, receiverRoute)
		}
		settingMatcher, err := labels.NewMatcher(labels.MatchEqual, RouteSettingsHashLabel, s.Fingerprint().String())
		if err != nil {
			return nil, err
		}

		receiverRoute.Routes = append(receiverRoute.Routes, &definitions.Route{
			Receiver:       s.Receiver,
			ObjectMatchers: definitions.ObjectMatchers{settingMatcher},
			Continue:       false, // Only a single setting-specific route should match.

			GroupByStr:        s.GroupBy,
			MuteTimeIntervals: s.MuteTimeIntervals,
			GroupWait:         s.GroupWait,
			GroupInterval:     s.GroupInterval,
			RepeatInterval:    s.RepeatInterval,
		})
	}

	return autoGenRoot, nil
}

// AddToConfig adds this autogenerated route to the user-created route in the provided config.
func (ar *AutogeneratedRoute) AddToConfig(config *definitions.PostableUserConfig) error {
	// Combine autogenerated route with the user-created route.
	if config.AlertmanagerConfig.Route != nil && ar.Route != nil {
		ar.Route.Receiver = config.AlertmanagerConfig.Route.Receiver
		config.AlertmanagerConfig.Route.Routes = slices.DeleteFunc(config.AlertmanagerConfig.Route.Routes, func(route *definitions.Route) bool {
			return len(route.ObjectMatchers) == 1 && route.ObjectMatchers[0].Name == AutogeneratedLabel
		})
		config.AlertmanagerConfig.Route.Routes = append([]*definitions.Route{ar.Route}, config.AlertmanagerConfig.Route.Routes...)
	}

	return nil
}

// Fingerprint returns a fingerprint constructed from all the base settings.
func (ar *AutogeneratedRoute) Fingerprint() data.Fingerprint {
	if ar.hash != 0 {
		return ar.hash
	}
	sum := fnv.New64()

	writeBytes := func(b []byte) {
		_, _ = sum.Write(b)
		_, _ = sum.Write([]byte{255})
	}

	// this temp slice is used to convert ints to bytes.
	tmp := make([]byte, 8)
	writeInt := func(fp data.Fingerprint) {
		binary.LittleEndian.PutUint64(tmp, uint64(fp))
		writeBytes(tmp)
	}

	fingerprints := make([]data.Fingerprint, len(ar.baseSettings))
	sort.Slice(fingerprints, func(i, j int) bool { return fingerprints[i] < fingerprints[j] })
	for _, fp := range fingerprints {
		writeInt(fp)
	}

	ar.hash = data.Fingerprint(sum.Sum64())
	return ar.hash
}
