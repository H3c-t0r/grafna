package models

import (
	"encoding/binary"
	"hash/fnv"
	"unsafe"

	"github.com/grafana/grafana-plugin-sdk-go/data"
	"github.com/prometheus/common/model"
)

const (
	ReceiverNameLabel      = "__grafana_receiver__"
	RouteSettingsHashLabel = "__grafana_route_settings_hash__"
	AutogeneratedLabel     = "__grafana_autogenerated__"
)

type NotificationSettings struct {
	Receiver string

	GroupBy           []string
	GroupWait         *model.Duration
	GroupInterval     *model.Duration
	RepeatInterval    *model.Duration
	MuteTimeIntervals []string
}

func (s *NotificationSettings) ToLabels() data.Labels {
	result := make(data.Labels, 3)
	result[AutogeneratedLabel] = "true"
	result[ReceiverNameLabel] = s.Receiver // TODO base64?
	if !s.isAllDefault() {
		result[RouteSettingsHashLabel] = s.Fingerprint().String()
	}
	return result
}

func (s *NotificationSettings) Equals(other *NotificationSettings) bool {
	if s == nil && other == nil {
		return true
	}
	if s == nil || other == nil {
		return false
	}
	if s.Receiver != other.Receiver {
		return false
	}
	if s.isAllDefault() == other.isAllDefault() {
		return true
	}
	return s.Fingerprint() == other.Fingerprint() // TODO improve it later
}

func (s *NotificationSettings) isAllDefault() bool {
	return len(s.GroupBy) == 0 && s.GroupWait == nil && s.GroupInterval == nil && s.RepeatInterval == nil && len(s.MuteTimeIntervals) == 0
}

func (s *NotificationSettings) Fingerprint() data.Fingerprint {
	h := fnv.New64()
	tmp := make([]byte, 8)

	writeString := func(s string) {
		// save on extra slice allocation when string is converted to bytes.
		_, _ = h.Write(unsafe.Slice(unsafe.StringData(s), len(s))) //nolint:gosec
		// ignore errors returned by Write method because fnv never returns them.
		_, _ = h.Write([]byte{255}) // use an invalid utf-8 sequence as separator
	}
	writeDuration := func(d *model.Duration) {
		if d == nil {
			_, _ = h.Write([]byte{255})
		} else {
			binary.LittleEndian.PutUint64(tmp, uint64(*d))
			_, _ = h.Write(tmp)
			_, _ = h.Write([]byte{255})
		}
	}

	writeString(s.Receiver)
	for _, gb := range s.GroupBy {
		writeString(gb)
	}
	writeDuration(s.GroupWait)
	writeDuration(s.GroupInterval)
	writeDuration(s.RepeatInterval)
	for _, interval := range s.MuteTimeIntervals {
		writeString(interval)
	}

	return data.Fingerprint(h.Sum64())
}
