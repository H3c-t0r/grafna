package notifiers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/grafana/grafana/pkg/bus"
	"github.com/grafana/grafana/pkg/infra/log"
	"github.com/grafana/grafana/pkg/models"
	"github.com/grafana/grafana/pkg/services/alerting"
	"github.com/grafana/grafana/pkg/setting"
)

func init() {
	alerting.RegisterNotifier(&alerting.NotifierPlugin{
		Type:        "wecom",
		Name:        "WeCom",
		Description: "Send alerts generated by Grafana to WeCom",
		Heading:     "WeCom settings",
		Factory:     NewWeComNotifier,
		Options: []alerting.NotifierOption{
			{
				Label:        "Url",
				Element:      alerting.ElementTypeInput,
				InputType:    alerting.InputTypeText,
				Placeholder:  "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxx",
				PropertyName: "url",
				Secure:       true,
				Required:     true,
			},
		},
	})
}

// NewWeComNotifier is the constructor for WeCom notifier.
func NewWeComNotifier(model *models.AlertNotification, fn alerting.GetDecryptedValueFn) (alerting.Notifier, error) {
	urlStr := fn(context.Background(), model.SecureSettings, "url", model.Settings.Get("url").MustString(), setting.SecretKey)
	webhookURL, err := url.Parse(urlStr)
	if err != nil {
		return nil, fmt.Errorf("invalid URL %q: %w", urlStr, err)
	}
	if webhookURL.String() == "" {
		return nil, alerting.ValidationError{Reason: "Could not find url property in settings"}
	}

	return &WeComNotifier{
		NotifierBase: NewNotifierBase(model),
		URL:          webhookURL.String(),
		log:          log.New("alerting.notifier.wecom"),
	}, nil
}

// WeComNotifier is responsible for sending alert notifications to WeCom.
type WeComNotifier struct {
	NotifierBase
	MsgType           string
	URL               string
	UploadSingleImage bool
	log               log.Logger
}

// Notify sends an alert notification to WeCom.
func (w *WeComNotifier) Notify(evalContext *alerting.EvalContext) error {
	w.log.Info("executing WeCom notification", "ruleId", evalContext.Rule.ID, "notification", w.Name)

	body, err := w.buildMarkdownBody(evalContext)
	if err != nil {
		return err
	}

	cmd := &models.SendWebhookSync{
		Url:  w.URL,
		Body: string(body),
	}

	if err := bus.DispatchCtx(evalContext.Ctx, cmd); err != nil {
		w.log.Error("Failed to send WeCom", "error", err, "wecom", w.Name)
		return err
	}

	return nil
}

func (w *WeComNotifier) truncate(str string, length int) string {
	if len(str) <= length {
		return str
	}
	return str[:length-1] + "..."
}

func (w *WeComNotifier) buildMarkdownBody(evalContext *alerting.EvalContext) ([]byte, error) {
	body := map[string]interface{}{
		"msgtype": "markdown",
	}
	content := fmt.Sprintf("# %v\nState: %s\n",
		evalContext.GetNotificationTitle(),
		evalContext.Rule.State,
	)

	if evalContext.Rule.Message != "" {
		content += fmt.Sprintf("Message: %s%v%s\n",
			"<font color=\"warning\">",
			w.truncate(evalContext.Rule.Message, 500),
			"</font>",
		)
	}

	messageURL, _ := evalContext.GetRuleURL()
	content += fmt.Sprintf("URL: [%s](%s)\n", messageURL, messageURL)
	if w.NeedsImage() && evalContext.ImagePublicURL != "" {
		content += fmt.Sprintf("Image: [%s](%s)\n",
			evalContext.ImagePublicURL, evalContext.ImagePublicURL)
	}

	for index, match := range evalContext.EvalMatches {
		if index == 0 {
			content += "> Metrics:\n"
		}

		if index > 4 {
			content += fmt.Sprintf("> [More](%s)\n", messageURL)
			break
		}

		content += fmt.Sprintf("> %d. <font color=\"comment\">%s</font> = `%s`\n",
			index+1, w.truncate(match.Metric, 500), match.Value)
	}

	body["markdown"] = map[string]interface{}{
		"content": content,
	}
	return json.Marshal(body)
}
