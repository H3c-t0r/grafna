package {{ .PackageName }}

import (
	"encoding/json"
	"fmt"
  "context"

	{{range .Kinds }}
	"{{ $.KindPackagePrefix }}/{{ .Props.MachineName }}"{{end}}
  "github.com/grafana/grafana/pkg/services/k8s/client"
  "github.com/grafana/grafana/pkg/services/k8s/informer"
	"github.com/grafana/grafana/pkg/services/k8s/crd"
	"github.com/grafana/grafana/pkg/registry/corekind"
  "github.com/grafana/dskit/services"
	"github.com/grafana/thema"
	"gopkg.in/yaml.v3"
)

// New constructs a new [Registry].
//
// All calling code within grafana/grafana is expected to use Grafana's
// singleton [thema.Runtime], returned from [cuectx.GrafanaThemaRuntime]. If nil
// is passed, the singleton will be used.
func New(
  rt *thema.Runtime,
  clientsetProvider client.ClientSetProvider,
  informerFactory informer.Informer,{{range $i, $k := .Kinds }}
  {{ $k.Props.MachineName }}Watcher {{ $k.Props.MachineName }}.Watcher,{{end}}
) *Registry {
	breg := corekind.NewBase(rt)
	r := doNewRegistry(
    breg,
    clientsetProvider,
    informerFactory,{{range $i, $k := .Kinds }}
    {{ $k.Props.MachineName }}Watcher,{{end}}
  )
  r.BasicService = services.NewBasicService(r.start, r.run, nil)
  return r
}

// All returns a slice of all core Grafana CRDs in the registry.
//
// The returned slice is guaranteed to be alphabetically sorted by kind name.
func (r *Registry) All() []crd.Kind {
	all := make([]crd.Kind, len(r.all))
	copy(all, r.all[:])
	return all
}

// Registry is a list of all of Grafana's core structured kinds, wrapped in a
// standard [crd.CRD] interface that makes them usable for interactions
// with certain Kubernetes controller and apimachinery libraries.
//
// There are two access methods: individually via literal named methods, or as
// a slice returned from All() method.
//
// Prefer the individual named methods for use cases where the particular kind(s)
// that are needed are known to the caller. Prefer All() when performing operations
// generically across all kinds.
type Registry struct {
  *services.BasicService
	all [{{ len .Kinds }}]crd.Kind
  clientsetProvider client.ClientSetProvider
  informerFactory informer.Informer{{range $i, $k := .Kinds }}
  {{ $k.Props.MachineName }}Watcher {{ $k.Props.MachineName }}.Watcher{{end}}
}

func (r *Registry) start(ctx context.Context) error {
   var (
    err error
    b []byte
  )
  clientSet := r.clientsetProvider.GetClientset()
  {{range $i, $k := .Kinds }}
   /************************ {{ $k.Props.Name }} ************************/
    // TODO Having the committed form on disk in YAML is worth doing this for now...but fix this silliness
    map{{ $i }} := make(map[string]any)
    err = yaml.Unmarshal({{ $k.Props.MachineName }}.CRDYaml, map{{ $i }})
    if err != nil {
      panic(fmt.Sprintf("generated CRD YAML for {{ $k.Props.Name }} failed to unmarshal: %s", err))
    }
    b, err = json.Marshal(map{{ $i }})
    if err != nil {
      panic(fmt.Sprintf("could not re-marshal CRD JSON for {{ $k.Props.Name }}: %s", err))
    }
    err = json.Unmarshal(b, &{{ $k.Props.MachineName }}.CRD.Schema)
    if err != nil {
      panic(fmt.Sprintf("could not unmarshal CRD JSON for {{ $k.Props.Name }}: %s", err))
    }

  err = clientSet.RegisterKind(ctx, {{ $k.Props.MachineName }}.CRD)
  if err != nil {
    panic(fmt.Sprintf("generated CRD for {{ $k.Props.Name }} failed to register: %s\n", err))
  }

  watcherWrapper{{ $i }} := {{ $k.Props.MachineName }}.NewWatcherWrapper(r.{{ $k.Props.MachineName }}Watcher)
  r.informerFactory.AddWatcher({{ $k.Props.MachineName}}.CRD, watcherWrapper{{ $i }})
{{end}}
  return nil
}

func (r *Registry) run(ctx context.Context) error {
  <-ctx.Done()
  return nil
}

{{range $i, $k := .Kinds }}
// {{ .Props.Name }} returns the [crd.Kind] instance for the {{ .Props.Name }} kind.
func (r *Registry) {{ .Props.Name }}() crd.Kind {
	return r.all[{{ $i }}]
}
{{end}}

func doNewRegistry(
  breg *corekind.Base,
  clientsetProvider client.ClientSetProvider,
  informerFactory informer.Informer,{{range $i, $k := .Kinds }}
  {{ $k.Props.MachineName }}Watcher {{ $k.Props.MachineName }}.Watcher,{{end}}
) *Registry {
reg := &Registry{}
reg.clientsetProvider = clientsetProvider
reg.informerFactory = informerFactory

{{range $i, $k := .Kinds }}
  reg.{{ $k.Props.MachineName }}Watcher = {{ $k.Props.MachineName }}Watcher
  reg.all[{{ $i }}] = {{ $k.Props.MachineName }}.CRD
{{end}}

	return reg
}
