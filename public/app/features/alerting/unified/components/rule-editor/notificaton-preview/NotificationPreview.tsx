import { css } from '@emotion/css';
import { compact } from 'lodash';
import React, { useEffect, useState } from 'react';

import { GrafanaTheme2 } from '@grafana/data';
import { Alert, Button, LoadingPlaceholder, useStyles2 } from '@grafana/ui';
import { AlertmanagerChoice } from 'app/plugins/datasource/alertmanager/types';

import { Stack } from '../../../../../../plugins/datasource/parca/QueryEditor/Stack';
import { AlertQuery, Labels } from '../../../../../../types/unified-alerting-dto';
import { alertRuleApi } from '../../../api/alertRuleApi';
import { alertmanagerApi } from '../../../api/alertmanagerApi';
import { useExternalDataSourceAlertmanagers } from '../../../hooks/useExternalAmSelector';
import { GRAFANA_RULES_SOURCE_NAME } from '../../../utils/datasource';

import { NotificationRoute } from './NotificationRoute';
import { useAlertmanagerNotificationRoutingPreview } from './useAlertmanagerNotificationRoutingPreview';

interface AlertManagerNameWithImage {
  name: string;
  img: string;
}

export const useGetAlertManagersSourceNamesAndImage = () => {
  //get current alerting config
  const { currentData: amConfigStatus } = alertmanagerApi.useGetAlertmanagerChoiceStatusQuery(undefined);

  const externalDsAlertManagers: AlertManagerNameWithImage[] = useExternalDataSourceAlertmanagers().map((ds) => ({
    name: ds.dataSource.name,
    img: ds.dataSource.meta.info.logos.small,
  }));
  const alertmanagerChoice = amConfigStatus?.alertmanagersChoice;
  const alertManagerSourceNamesWithImage: AlertManagerNameWithImage[] =
    alertmanagerChoice === AlertmanagerChoice.Internal
      ? [{ name: GRAFANA_RULES_SOURCE_NAME, img: 'public/img/grafana_icon.svg' }]
      : alertmanagerChoice === AlertmanagerChoice.External
      ? externalDsAlertManagers
      : [{ name: GRAFANA_RULES_SOURCE_NAME, img: 'public/img/grafana_icon.svg' }, ...externalDsAlertManagers];

  return alertManagerSourceNamesWithImage;
};

interface NotificationPreviewProps {
  customLabels: Array<{
    key: string;
    value: string;
  }>;
  alertQueries: AlertQuery[];
  condition: string;
}

export const NOTIFICATION_PREVIEW_TITLE = 'Alert instance routing preview';

export const NotificationPreview = ({ alertQueries, customLabels, condition }: NotificationPreviewProps) => {
  const styles = useStyles2(getStyles);
  // potential instances are the instances that are going to be routed to the notification policies
  const [potentialInstances, setPotentialInstances] = useState<Labels[]>([]);

  const { usePreviewMutation } = alertRuleApi;

  const [trigger, { data, isLoading }] = usePreviewMutation();

  useEffect(() => {
    // any time data is updated from trigger, we need to update the potential instances
    // convert data to list of labels: are the representation of the potential instances
    if (!isLoading) {
      const fields = data?.schema?.fields ?? [];
      const potentialInstances = compact(fields.map((field) => field.labels));
      setPotentialInstances(potentialInstances);
    }
  }, [data, isLoading]);

  const onPreview = () => {
    // Get the potential labels given the alert queries, the condition and the custom labels (autogenerated labels are calculated on the BE side)
    trigger({ alertQueries: alertQueries, condition: condition, customLabels: customLabels });
  };

  // Get alert managers source names
  const alertManagerSourceNamesAndImage = useGetAlertManagersSourceNamesAndImage();

  const onlyOneAM = alertManagerSourceNamesAndImage.length === 1;
  const renderHowToPreview = !data?.schema && !isLoading;

  return (
    <Stack direction="column" gap={2}>
      <div className={styles.routePreviewHeaderRow}>
        <h4 className={styles.previewHeader}>{NOTIFICATION_PREVIEW_TITLE}</h4>
        <div className={styles.button}>
          <Button icon="sync" variant="secondary" type="button" onClick={onPreview}>
            Preview routing
          </Button>
        </div>
      </div>
      <div className={styles.textMuted}>
        Based on the labels you have added above and the labels that have been automatically assigned, alert instances
        are being route to notification policies in the way listed bellow. Expand the notification policies to see the
        instances which are going to be routed to them.
      </div>
      {isLoading && <div className={styles.textMuted}>Loading...</div>}
      {renderHowToPreview && (
        <div className={styles.previewHowToText}>
          {`When your query and labels are configured, click "Preview routing" to see the results here.`}
        </div>
      )}
      {!isLoading &&
        alertManagerSourceNamesAndImage.map((alertManagerSource) => {
          return (
            <NotificationPreviewByAlertManager
              alertManagerSource={alertManagerSource}
              potentialInstances={potentialInstances}
              onlyOneAM={onlyOneAM}
              key={alertManagerSource.name}
            />
          );
        })}
    </Stack>
  );
};

export function NotificationPreviewByAlertManager({
  alertManagerSource,
  potentialInstances,
  onlyOneAM,
}: {
  alertManagerSource: AlertManagerNameWithImage;
  potentialInstances: Labels[];
  onlyOneAM: boolean;
}) {
  const styles = useStyles2(getStyles);

  const { routesByIdMap, receiversByName, matchingMap, loading, error } = useAlertmanagerNotificationRoutingPreview(
    alertManagerSource.name,
    potentialInstances
  );

  if (error) {
    return (
      <Alert title="Cannot load Alertmanager configuration" severity="error">
        {error.message}
      </Alert>
    );
  }

  if (loading) {
    return <LoadingPlaceholder text="Loading routing preview..." />;
  }

  const matchingPoliciesFound = matchingMap.size > 0;

  return matchingPoliciesFound ? (
    <div className={styles.alertManagerRow}>
      {!onlyOneAM && (
        <Stack direction="row" alignItems="center">
          <div className={styles.firstAlertManagerLine}></div>
          <div className={styles.alertManagerName}>
            {' '}
            Alert manager:
            <img src={alertManagerSource.img} alt="" className={styles.img} />
            {alertManagerSource.name}
          </div>
          <div className={styles.secondAlertManagerLine}></div>
        </Stack>
      )}
      <Stack gap={1} direction="column">
        {Array.from(matchingMap.entries()).map(([routeId, instanceMatches]) => {
          const route = routesByIdMap.get(routeId);
          const receiver = route?.receiver && receiversByName.get(route.receiver);
          if (!route || !receiver) {
            return null;
          }
          return (
            <NotificationRoute
              instanceMatches={instanceMatches}
              route={route}
              receiver={receiver}
              key={routeId}
              routesByIdMap={routesByIdMap}
              alertManagerSourceName={alertManagerSource.name}
            />
          );
        })}
      </Stack>
    </div>
  ) : null;
}

const getStyles = (theme: GrafanaTheme2) => ({
  collapsableSection: css`
    width: auto;
    border: 0;
  `,
  textMuted: css`
    color: ${theme.colors.text.secondary};
  `,
  previewHowToText: css`
    display: flex;
    color: ${theme.colors.text.secondary};
    justify-content: center;
    font-size: ${theme.typography.size.sm};
  `,
  previewHeader: css`
    margin: 0;
  `,
  routePreviewHeaderRow: css`
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  `,
  collapseLabel: css`
    flex: 1;
  `,
  button: css`
    justify-content: flex-end;
    display: flex;
  `,
  alertManagerRow: css`
    margin-top: ${theme.spacing(2)};
    display: flex;
    flex-direction: column;
    gap: ${theme.spacing(1)};
    width: 100%;
  `,
  alertManagerName: css`
    width: fit-content;
  `,
  firstAlertManagerLine: css`
    height: 1px;
    width: ${theme.spacing(4)};
    background-color: ${theme.colors.secondary.main};
  `,
  secondAlertManagerLine: css`
    height: 1px;
    width: 100%;
    flex: 1;
    background-color: ${theme.colors.secondary.main};
  `,
  tagsInDetails: css`
    display: flex;
    justify-content: flex-start;
    flex-wrap: wrap;
  `,
  policyPathItemMatchers: css`
    display: flex;
    flex-direction: row;
    gap: ${theme.spacing(1)};
  `,
  img: css`
    margin-left: ${theme.spacing(2)};
    width: ${theme.spacing(3)};
    height: ${theme.spacing(3)};
    margin-right: ${theme.spacing(1)};
  `,
});
